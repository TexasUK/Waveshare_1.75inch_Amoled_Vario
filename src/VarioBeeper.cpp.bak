#include "VarioBeeper.h"
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "driver/i2s.h"
#include "pins_config.h"

// We DO NOT (re)initialize ES8311 or I²S here.
// We just write PCM to whichever I²S port SetupSound() already opened.
#ifndef VARIO_FS_HZ
#define VARIO_FS_HZ 16000   // set to 8000 if your init uses 8 kHz
#endif
#define VARIO_BUF_SAMPLES 256
#define VARIO_OUTPUT_SCALE 0.25f

static TaskHandle_t s_task = nullptr;
static SemaphoreHandle_t s_vz_mutex = nullptr;
static float s_vz_mps = 0.0f;
static bool s_muted = false;

// ----- mapping Vz -> beep shape -----
static inline float clampf(float x, float lo, float hi){return x<lo?lo:(x>hi?hi:x);}
struct Tone { float f, on_ms, off_ms; bool cont; };

static void shape_from_vz(float vz, Tone& t) {
  if (vz > -0.5f && vz < 0.2f) { t = {0,0,120,false}; return; }
  if (vz <= -2.0f) { float a=clampf(fabsf(vz),2,6); t={clampf(300+120*(a-2),300,900),1000,0,true}; return; }
  if (vz < -0.5f) { float a=clampf((-vz-0.5f)/1.5f,0,1); t={350-100*a,140+160*(1-a),420+280*a,false}; return; }
  float a=clampf((vz-0.2f)/3.0f,0,1);
  float period=600-450*a, duty=0.35f+0.30f*a;
  t = {700+900*a, period*duty, period*(1-duty), false};
}

static inline int16_t next_sine(float& ph, float f){
  float s = sinf(ph) * VARIO_OUTPUT_SCALE;
  ph += 2.0f * (float)M_PI * (f / (float)VARIO_FS_HZ);
  if (ph >= 2.0f * (float)M_PI) ph -= 2.0f * (float)M_PI;
  return (int16_t)(s * 32767.0f);
}

static void beeper_task(void*) {
  const size_t bytes = VARIO_BUF_SAMPLES * sizeof(int16_t);
  int16_t *buf = (int16_t*)heap_caps_malloc(bytes, MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT);
  float phase = 0; uint32_t gate_us_left = 0; bool gate_on = false;

  for(;;){
    float vz; bool muted;
    if (xSemaphoreTake(s_vz_mutex, portMAX_DELAY)) { vz = s_vz_mps; muted = s_muted; xSemaphoreGive(s_vz_mutex); }

    Tone t{}; shape_from_vz(vz, t);

    if (muted || t.f < 1.0f){
      memset(buf, 0, bytes);
      size_t w=0; i2s_write((i2s_port_t)0, buf, bytes, &w, portMAX_DELAY);
      gate_us_left = 0; gate_on = false; continue;
    }

    if (gate_us_left==0){ gate_on = t.cont ? true : !gate_on; gate_us_left = (uint32_t)((gate_on? t.on_ms : t.off_ms)*1000.0f); }

    uint32_t chunk_us = (uint32_t)((VARIO_BUF_SAMPLES * 1000000ULL) / VARIO_FS_HZ);
    size_t frames = VARIO_BUF_SAMPLES;
    if (!t.cont && gate_us_left < chunk_us){
      chunk_us = gate_us_left;
      frames = (size_t)((gate_us_left * (uint64_t)VARIO_FS_HZ) / 1000000ULL);
    }

    const bool play = gate_on || t.cont;
    for (size_t i=0;i<frames;++i) buf[i] = play ? next_sine(phase, t.f) : 0;
    for (size_t i=frames;i<VARIO_BUF_SAMPLES;++i) buf[i]=0;

    size_t w=0; i2s_write((i2s_port_t)0, buf, bytes, &w, portMAX_DELAY);

    if (!t.cont){
      if (gate_us_left>chunk_us) gate_us_left -= chunk_us; else gate_us_left = 0;
      if (gate_us_left==0 && !gate_on && t.off_ms<=0.0f) gate_on = true;
    }
  }
}

namespace VarioBeeper {
  bool begin(uint32_t sampleRateHz){
    // The beeper assumes I²S0 is already installed & set to 'sampleRateHz'
    // by your audio init (SetupSound). We don't touch codec or I²S config.
    (void)sampleRateHz;
    if (!s_vz_mutex) s_vz_mutex = xSemaphoreCreateMutex();
    if (!s_task){
      BaseType_t ok = xTaskCreatePinnedToCore(beeper_task,"vario_beep",4096,nullptr,5,&s_task,tskNO_AFFINITY);
      if (ok != pdPASS) return false;
    }
    return true;
  }
  void setVz(float vz){ if (!s_vz_mutex) return; if (xSemaphoreTake(s_vz_mutex, portMAX_DELAY)){ s_vz_mps=vz; xSemaphoreGive(s_vz_mutex);} }
  void mute(bool on){ if (!s_vz_mutex) return; if (xSemaphoreTake(s_vz_mutex, portMAX_DELAY)){ s_muted=on; xSemaphoreGive(s_vz_mutex);} }
  void end(){ if (s_task){ vTaskDelete(s_task); s_task=nullptr; } }
}
